<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Nerdcore Museum 2 â€” COOL Player</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <!-- Include jsmediatags UMD locally with CDN fallback -->
  <script src="dist/jsmediatags.min.js"></script>
  <script>
    // Fallback to CDN if local not loaded within 1s
    setTimeout(() => {
      if (!window.jsmediatags) {
        const s = document.createElement('script');
        s.src = 'https://cdn.jsdelivr.net/npm/jsmediatags@3.9.5/dist/jsmediatags.min.js';
        document.head.appendChild(s);
      }
    }, 1000);
  </script>
  <style>
    /* existing CSS unchanged */
  </style>
</head>
<body>
  <header><h1>ğŸ§ Nerdcore COOL Player</h1></header>
  <main>
    <nav id="folders"></nav>
    <section id="player">
      <img id="cover" src="" alt="Cover Art">
      <div id="track-info">Loadingâ€¦</div>
      <audio id="audio" preload="metadata" crossorigin="anonymous"></audio>
      <div id="controls">
        <button id="prev">â®ï¸</button>
        <button id="rew">âª</button>
        <button id="play">â–¶ï¸</button>
        <button id="ff">â©</button>
        <button id="next">â­ï¸</button>
        <button id="loop">ğŸ”</button>
      </div>
      <input type="range" id="seek" value="0" min="0" max="100">
    </section>
  </main>
  <footer>
    <button id="next-folder">Next Folder â†’</button>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      const owner = 'Emon2358', repo = 'nerdcore-Museum-2', pathAlbums = 'albums';
      const foldersEl = document.getElementById('folders');
      const audio = document.getElementById('audio');
      const cover = document.getElementById('cover');
      const info = document.getElementById('track-info');

      // Map button IDs to elements
      const btnIds = ['prev','rew','play','ff','next','loop','seek','next-folder'];
      const btn = btnIds.reduce((o, id) => {
        const key = id === 'next-folder' ? 'nextFolder' : id;
        o[key] = document.getElementById(id);
        return o;
      }, {});

      let folders = [], curFolder = 0, tracks = [], curTrack = 0;

      async function loadFolders() {
        try {
          const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${pathAlbums}`);
          const items = await res.json();
          folders = items.filter(i => i.type === 'dir');
          foldersEl.innerHTML = '';
          folders.forEach((f, i) => {
            const b = document.createElement('button');
            b.textContent = f.name; // safe, no decoding
            b.onclick = () => selectFolder(i);
            foldersEl.appendChild(b);
          });
          if (folders.length) selectFolder(0);
          else info.textContent = 'No folders available';
        } catch (e) {
          console.error('Error loading folders:', e);
          info.textContent = 'Failed to load folders';
        }
      }

      async function selectFolder(idx) {
        curFolder = idx; curTrack = 0;
        [...foldersEl.children].forEach((b, i) => b.classList.toggle('active', i === idx));
        try {
          const res = await fetch(folders[idx].url);
          const items = await res.json();
          tracks = items.filter(i => i.name.toLowerCase().endsWith('.mp3'))
                        .map(i => ({ name: i.name, url: i.download_url }));
          if (tracks.length === 0) {
            info.textContent = 'No tracks available'; cover.src = '';
          } else {
            loadTrack(0);
          }
        } catch (e) {
          console.error('Error selecting folder:', e);
          info.textContent = 'Failed to load tracks';
        }
      }

      function loadTrack(i) {
        curTrack = i;
        audio.src = tracks[i].url;
        info.textContent = tracks[i].name;
        cover.classList.remove('playing');
        loadCover(tracks[i].url);
        try {
          audio.load();
          audio.play().catch(e => console.warn('Play interrupted:', e.name));
        } catch (e) {
          console.warn('Audio play error:', e);
        }
        updateMediaSession();
        updateLoopUI();
      }

      function loadCover(url) {
        if (!window.jsmediatags) {
          console.warn('jsmediatags not available'); cover.src = '';
          return;
        }
        jsmediatags.read(url, {
          onSuccess: tag => {
            const pic = tag.tags.picture;
            if (pic) {
              const blob = new Blob([new Uint8Array(pic.data)], { type: pic.format });
              cover.src = URL.createObjectURL(blob);
            } else cover.src = '';
          },
          onError: e => { console.warn('Cover load error', e); cover.src = ''; }
        });
      }

      function updateMediaSession() {
        if ('mediaSession' in navigator) {
          navigator.mediaSession.metadata = new MediaMetadata({
            title: tracks[curTrack].name,
            artwork: cover.src ? [{ src: cover.src, sizes: '500x500' }] : []
          });
        }
      }

      function updateLoopUI() {
        btn.loop.textContent = audio.loop ? 'ğŸ” On' : 'ğŸ” Off';
      }

      // Event listeners
      btn.play.onclick       = () => audio.paused ? audio.play().catch(()=>{}) : audio.pause();
      btn.prev.onclick       = () => tracks.length && loadTrack((curTrack - 1 + tracks.length) % tracks.length);
      btn.next.onclick       = () => tracks.length && loadTrack((curTrack + 1) % tracks.length);
      btn.rew.onclick        = () => audio.currentTime = Math.max(0, audio.currentTime - 10);
      btn.ff.onclick         = () => audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + 10);
      btn.loop.onclick       = () => { audio.loop = !audio.loop; updateLoopUI(); };
      btn.seek.oninput       = e => { if (audio.duration) audio.currentTime = audio.duration * (e.target.value / 100); };
      btn.nextFolder.onclick = () => folders.length && selectFolder((curFolder + 1) % folders.length);

      audio.onplay          = () => { btn.play.textContent = 'â¸ï¸'; cover.classList.add('playing'); };
      audio.onpause         = () => { btn.play.textContent = 'â–¶ï¸'; cover.classList.remove('playing'); };
      audio.ontimeupdate    = () => { if (audio.duration) btn.seek.value = (audio.currentTime / audio.duration) * 100; };

      await loadFolders();
    });
  </script>
</body>
</html>
