<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Nerdcore Museum 2 â€” COOL Player</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <!-- Include jsmediatags from local dist for UMD usage -->
  <script src="dist/jsmediatags.min.js"></script>
  <style>
    :root { /* colors, shadows */ }
    /* ... existing CSS unchanged ... */
  </style>
</head>
<body>
  <header><h1>ğŸ§ Nerdcore COOL Player</h1></header>
  <main>
    <nav id="folders"></nav>
    <section id="player">
      <img id="cover" src="" alt="Cover Art">
      <div id="track-info">Loadingâ€¦</div>
      <audio id="audio" preload="metadata" crossorigin="anonymous"></audio>
      <div id="controls">
        <button id="prev">â®ï¸</button>
        <button id="rew">âª</button>
        <button id="play">â–¶ï¸</button>
        <button id="ff">â©</button>
        <button id="next">â­ï¸</button>
        <button id="loop">ğŸ”</button>
      </div>
      <input type="range" id="seek" value="0" min="0" max="100">
    </section>
  </main>
  <footer>
    <button id="next-folder">Next Folder â†’</button>
  </footer>

  <script>
    // Main logic runs after DOM is ready
    document.addEventListener('DOMContentLoaded', async () => {
      const owner = 'Emon2358', repo = 'nerdcore-Museum-2', pathAlbums = 'albums';
      const foldersEl = document.getElementById('folders');
      const audio = document.getElementById('audio');
      const cover = document.getElementById('cover');
      const info = document.getElementById('track-info');

      // Map button IDs to elements
      const btnIds = ['prev','rew','play','ff','next','loop','seek','next-folder'];
      const btn = btnIds.reduce((o, id) => {
        const key = id === 'next-folder' ? 'nextFolder' : id;
        o[key] = document.getElementById(id);
        return o;
      }, {});

      let folders = [], curFolder = 0, tracks = [], curTrack = 0;

      async function loadFolders() {
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${pathAlbums}`);
        const items = await res.json();
        folders = items.filter(i => i.type === 'dir');
        foldersEl.innerHTML = '';
        folders.forEach((f, i) => {
          const b = document.createElement('button');
          b.textContent = f.name;
          b.onclick = () => selectFolder(i);
          foldersEl.appendChild(b);
        });
        selectFolder(0);
      }

      async function selectFolder(idx) {
        curFolder = idx; curTrack = 0;
        [...foldersEl.children].forEach((b, i) => b.classList.toggle('active', i === idx));
        const res = await fetch(folders[idx].url);
        const items = await res.json();
        tracks = items.filter(i => i.name.toLowerCase().endsWith('.mp3'))
                      .map(i => ({ name: i.name, url: i.download_url }));
        if (tracks.length === 0) {
          info.textContent = 'No tracks available';
          cover.src = '';
          return;
        }
        loadTrack(0);
      }

      function loadTrack(i) {
        curTrack = i;
        audio.src = tracks[i].url;
        info.textContent = tracks[i].name;
        cover.classList.remove('playing');
        loadCover(tracks[i].url);
        audio.load();
        audio.play().catch(() => {});
        updateMediaSession();
        updateLoopUI();
      }

      function loadCover(url) {
        if (!window.jsmediatags) {
          console.warn('jsmediatags UMD not available');
          cover.src = '';
          return;
        }
        jsmediatags.read(url, {
          onSuccess: tag => {
            const pic = tag.tags.picture;
            if (pic) {
              const blob = new Blob([new Uint8Array(pic.data)], { type: pic.format });
              cover.src = URL.createObjectURL(blob);
            } else {
              cover.src = '';
            }
          },
          onError: () => { cover.src = ''; }
        });
      }

      function updateMediaSession() {
        if ('mediaSession' in navigator) {
          navigator.mediaSession.metadata = new MediaMetadata({
            title: tracks[curTrack].name,
            artwork: cover.src ? [{ src: cover.src, sizes: '500x500' }] : []
          });
        }
      }

      function updateLoopUI() {
        btn.loop.textContent = audio.loop ? 'ğŸ” On' : 'ğŸ” Off';
      }

      // Event listeners
      btn.play.onclick       = () => audio.paused ? audio.play() : audio.pause();
      btn.prev.onclick       = () => loadTrack((curTrack - 1 + tracks.length) % tracks.length);
      btn.next.onclick       = () => loadTrack((curTrack + 1) % tracks.length);
      btn.rew.onclick        = () => audio.currentTime = Math.max(0, audio.currentTime - 10);
      btn.ff.onclick         = () => audio.currentTime = Math.min(audio.duration || 0, audio.currentTime + 10);
      btn.loop.onclick       = () => { audio.loop = !audio.loop; updateLoopUI(); };
      btn.seek.oninput       = e => { if (audio.duration) audio.currentTime = audio.duration * (e.target.value / 100); };
      btn.nextFolder.onclick = () => selectFolder((curFolder + 1) % folders.length);

      audio.onplay          = () => { btn.play.textContent = 'â¸ï¸'; cover.classList.add('playing'); };
      audio.onpause         = () => { btn.play.textContent = 'â–¶ï¸'; cover.classList.remove('playing'); };
      audio.ontimeupdate    = () => { if (audio.duration) btn.seek.value = audio.currentTime / audio.duration * 100; };

      await loadFolders();
    });
  </script>
</body>
</html>
